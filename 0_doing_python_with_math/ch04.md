[]{#page_93}**[4]{.big}** **Algebra and Symbolic Math with SymPy** {#ch04 .h2}
------------------------------------------------------------------

::: {.image1}
![image](graphics/common-01.jpg)
:::

The mathematical problems and solutions in our programs so far have all
involved the manipulation of numbers. But there's another way math is
taught, learned, and practiced, and that's in terms of symbols and the
operations between them. Just think of all the *x*s and *y*s in a
typical algebra problem. We refer to this type of math as *symbolic
math*. I'm sure you remember those dreaded "factorize *x*^3^ + 3*x*^2^ +
3*x* + 1" problems in your math class. Fear no more, for in this
chapter, we learn how to write programs that can solve such problems and
much more. To do so, we'll use *SymPy*---a Python library that lets you
write expressions containing symbols and perform operations on them.
Because this is a third-party library, you'll need to install it before
you can use it in your programs. The installation instructions are
described in [Appendix A](app01.html#app01).

### []{#page_94}**Defining Symbols and Symbolic Operations** {#ch04lev1sec01 .h3}

*Symbols* form the building blocks of symbolic math. The term *symbol*
is just a general name for the *x*s, *y*s, *a*s, and *b*s you use in
equations and algebraic expressions. Creating and using symbols will let
us do things differently than before. Consider the following statements:

\>\>\> [x = 1]{.codestrong}\
\>\>\> [x + x + 1]{.codestrong}\
3

Here we create a label, [x]{.literal}, to refer to the number 1. Then,
when we write the statement [x + x + 1]{.literal}, it's evaluated for
us, and the result is 3. What if you wanted the result in terms of the
symbol *x*? That is, if instead of 3, you wanted Python to tell you that
the result is 2*x* + 1? You couldn't just write [x + x + 1]{.literal}
*without* the statement [x = 1]{.literal} because Python wouldn't know
what [x]{.literal} refers to.

SymPy lets us write programs where we can express and evaluate
mathematical expressions in terms of such symbols. To use a symbol in
your program, you have to create an object of the [Symbol]{.literal}
class, like this:

\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}

First, we import the [Symbol]{.literal} class from the [sympy]{.literal}
library. Then, we create an object of this class passing
[\'x\']{.literal} as a parameter. Note that this [\'x\']{.literal} is
written as a string within quotes. We can now define expressions and
equations in terms of this symbol. For example, here's the earlier
expression:

\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [x + x + 1]{.codestrong}\
2\*x + 1

Now the result is given in terms of the symbol *x*. In the statement [x
= Symbol(\'x\')]{.literal}, the [x]{.literal} on the left side is the
Python label. This is the same kind of label we've used before, except
this time it refers to the symbol *x* instead of a number---more
specifically, a [Symbol]{.literal} object representing the symbol
[\'x\']{.literal}. This label doesn't necessarily have to match the
symbol either--- we could have used a label like [a]{.literal} or
[var1]{.literal} instead. So, it's perfectly fine to write the preceding
statements as follows:

\>\>\> [a = Symbol(\'x\')]{.codestrong}\
\>\>\> [a + a + 1]{.codestrong}\
2\*x + 1

Using a non-matching label can be confusing, however, so I would
recommend choosing a label that's the same letter as the symbol it
refers to.

::: {.sidebar}
[]{#page_95}**FINDING THE SYMBOL REPRESENTED BY A SYMBOL OBJECT**

For any [Symbol]{.literal} object, its [name]{.literal} attribute is a
string that is the actual symbol it represents:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [x.name]{.codestrong}\
\'x\'\
\>\>\> [a = Symbol(\'x\')]{.codestrong}\
\>\>\> [a.name]{.codestrong}\
\'x\'

You can use [.name]{.literal} on a label to retrieve the symbol that it
is storing.
:::

Just to be clear, the symbol you create has to be specified as a string.
For example, you can't create the symbol *x* using [x =
Symbol(x)]{.literal}---you must define it as [x =
Symbol(\'x\')]{.literal}.

To define multiple symbols, you can either create separate
[Symbol]{.literal} objects or use the [symbols()]{.literal} function to
define them more concisely. Let's say you wanted to use three
symbols---*x*, *y*, and *z*---in your program. You could define them
individually, as we did earlier:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [y = Symbol(\'y\')]{.codestrong}\
\>\>\> [z = Symbol(\'z\')]{.codestrong}

But a shorter method would be to use the [symbols()]{.literal} function
to define all three at once:

\>\>\> [from sympy import symbols]{.codestrong}\
\>\>\> [x,y,z = symbols(\'x,y,z\')]{.codestrong}

First, we import the [symbols()]{.literal} function from SymPy. Then, we
call it with the three symbols we want to create, written as a string
with commas separating them. After this statement is executed,
[x]{.literal}, [y]{.literal}, and [z]{.literal} will refer to the three
symbols [\'x\']{.literal}, [\'y\']{.literal}, and [\'z\']{.literal}.

Once you've defined symbols, you can carry out basic mathematical
operations on them, using the same operators you learned in [Chapter
1](ch01.html#ch01) ([+]{.literal}, [-]{.literal}, [/]{.literal},
[\*]{.literal}, and [\*\*]{.literal}). For example, you might do the
following:

\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [y = Symbol(\'y\')]{.codestrong}\
[]{#page_96}\
\>\>\> [s = x\*y + x\*y]{.codestrong}\
\>\>\> [s]{.codestrong}\
2\*x\*y

Let's see whether we can find the product of [x(x + x)]{.literal}:

\>\>\> [p = x\*(x + x)]{.codestrong}\
\>\>\> [p]{.codestrong}\
2\*x\*\*2

SymPy will automatically make these simple addition and multiplication
calculations, but if we enter a more complex expression, it will remain
unchanged. Let's see what happens when we enter the expression [(x +
2)\*(x + 3)]{.literal}:

\>\>\> [p = (x + 2)\*(x + 3)]{.codestrong}\
\>\>\> [p]{.codestrong}\
(x + 2)\*(x + 3)

You may have expected SymPy to multiply everything out and output
[x\*\*2 + 5\*x + 6]{.literal}. Instead, the expression was printed
exactly how we entered it. SymPy automatically simplifies only the most
basic of expressions and leaves it to the programmer to explicitly
require simplification in cases such as the preceding one. If you want
to multiply out the expression to get the expanded version, you'll have
to use the [expand()]{.literal} function, which we'll see in a moment.

### **Working with Expressions** {#ch04lev1sec02 .h3}

Now that we know how to define our own symbolic expressions, let's learn
more about using them in our programs.

#### ***Factorizing and Expanding Expressions*** {#ch04lev2sec01 .h4}

The [factor()]{.literal} function decomposes an expression into its
factors, and the [expand()]{.literal} function expands an expression,
expressing it as a sum of individual terms. Let's test out these
functions with the basic algebraic identity *x*^2^ -- *y*^2^ = (*x* +
*y*)(*x* -- *y*). The left side of the identity is the expanded version,
and the right side depicts the corresponding factorization. Because we
have two symbols in the identity, we'll create two [Symbol]{.literal}
objects:

\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [y = Symbol(\'y\')]{.codestrong}

[]{#page_97}Next, we import the [factor()]{.literal} function and use it
to convert the expanded version (on the left side of the identity) to
the factored version (on the right side):

\>\>\> [from sympy import factor]{.codestrong}\
\>\>\> [expr = x\*\*2 - y\*\*2]{.codestrong}\
\>\>\> [factor(expr)]{.codestrong}\
(x - y)\*(x + y)

As expected, we get the factored version of the expression. Now let's
expand the factors to get back the original expanded version:

\>\>\> [from sympy import expand]{.codestrong}\
\>\>\> [factors = factor(expr)]{.codestrong}\
\>\>\> [expand(factors)]{.codestrong}\
x\*\*2 - y\*\*2

We store the factorized expression in a new label, [factors]{.literal},
and then call the [expand()]{.literal} function with it. When we do
this, we receive the original expression we started with. Let's try it
with the more complicated identity *x*^3^ + 3*x*^2^*y* + 3*xy*^2^ +
*y*^3^ = (*x* + *y*)^3^:

\>\>\> [expr = x\*\*3 + 3\*x\*\*2\*y + 3\*x\*y\*\*2 + y\*\*3]{.codestrong}\
\>\>\> [factors = factor(expr)]{.codestrong}\
\>\>\> [factors]{.codestrong}\
(x + y)\*\*3\
\
\>\>\> [expand(factors)]{.codestrong}\
x\*\*3 + 3\*x\*\*2\*y + 3\*x\*y\*\*2 + y\*\*3

The [factor()]{.literal} function is able to factorize the expression,
and then the [expand()]{.literal} function expands the factorized
expression to return to the original expression.

If you try to factorize an expression for which there's no possible
factorization, the original expression is returned by the
[factor()]{.literal} function. For example, see the following:

\>\>\> [expr = x + y + x\*y]{.codestrong}\
\>\>\> [factor(expr)]{.codestrong}\
x\*y + x + y

Similarly, if you pass in an expression to [expand()]{.literal} that
can't be expanded further, it returns the same expression.

#### ***Pretty Printing*** {#ch04lev2sec02 .h4}

If you want the expressions we've been working with to look a bit nicer
when you print them, you can use the [pprint()]{.literal} function. This
function will print the expression in a way that more closely resembles
how we'd normally write it on paper. For example, here's an expression:

\>\>\> [expr = x\*x + 2\*x\*y + y\*y]{.codestrong}

[]{#page_98}If we print it as we've been doing so far or use the
[print()]{.literal} function, this is how it looks:

\>\>\> [expr]{.codestrong}\
x\*\*2 + 2\*x\*y + y\*\*2

Now, let's use the [pprint()]{.literal} function to print the preceding
expression:

\>\>\> [from sympy import pprint]{.codestrong}\
\>\>\> [pprint(expr)]{.codestrong}\
x^2^ + 2·x·y + y^2^

The expression now looks much cleaner---for example, instead of having a
bunch of ugly asterisks, exponents appear above the rest of the numbers.

You can also change the order of the terms when you print an expression.
Consider the expression 1 + 2*x* + 2*x*^2^:

\>\>\> [expr = 1 + 2\*x + 2\*x\*\*2]{.codestrong}\
\>\>\> [pprint(expr)]{.codestrong}\
2·x^2^ + 2·x + 1

The terms are arranged in the order of powers of *x*, from highest to
lowest. If you want the expression in the opposite order, with the
highest power of *x* last, you can make that happen with the
[init\_printing()]{.literal} function, as follows:

\>\>\> [from sympy import init\_printing]{.codestrong}\
\>\>\> [init\_printing(order=\'rev-lex\')]{.codestrong}\
\>\>\> [pprint(expr)]{.codestrong}\
1 + 2·x + 2·x^2^

The [init\_printing()]{.literal} function is first imported and called
with the keyword argument [order=\'rev-lex\']{.literal}. This indicates
that we want SymPy to print the expressions so that they're in *reverse
lexicographical order*. In this case, the keyword argument tells Python
to print the lower-power terms first.

::: {.note}
**[NOTE]{.bordera}**

*Although we used the* [[init\_printing()]{.codeitalic}]{.literal}
*function here to set the printed order of the expressions, this
function can be used in many other ways to configure how an expression
is printed. For more options and to learn more about printing in SymPy,
see the documentation at*
<http://docs.sympy.org/latest/tutorial/printing.html>.
:::

Let's apply what we've learned so far to implement a series printing
program.

##### []{#page_99}**Printing a Series** {#ch04lev3sec01 .h5}

Consider the following series:

::: {.image2}
![image](graphics/e0099-01.jpg)
:::

Let's write a program that will ask a user to input a number, *n*, and
print this series for that number. In the series, *x* is a symbol and
*n* is an integer input by the program's user. The *n*th term in this
series is given by

::: {.image2}
![image](graphics/e0099-02.jpg)
:::

We can print this series using the following program:

   \'\'\'\
   Print the series:\
   x + x\*\*2 + x\*\*3 + \... + x\*\*n\
       \_\_\_\_  \_\_\_\_\_         \_\_\_\_\_\
         2    3              n\
   \'\'\'\
\
   from sympy import Symbol, pprint, init\_printing\
   def print\_series(n):\
\
       \# Initialize printing system with reverse order\
       init\_printing(order=\'rev-lex\')\
\
       x = Symbol(\'x\')\
[➊]{.ent}     series = x\
[➋]{.ent}     for i in range(2, n+1):\
[➌]{.ent}         series = series + (x\*\*i)/i\
       pprint(series)\
\
   if \_\_name\_\_ == \'\_\_main\_\_\':\
       n = input(\'Enter the number of terms you want in the series: \')\
[➍]{.ent}     print\_series(int(n))

The [print\_series()]{.literal} function accepts an integer,
[n]{.literal}, as a parameter that is the number of terms in the series
that will be printed. Note that we convert the input to an integer using
the [int()]{.literal} function when calling the function at [➍]{.ent}.
We then call the [init\_printing()]{.literal} function to set the series
to print in reverse lexicographical order.

At [➊]{.ent}, we create the label, [series]{.literal}, and set its
initial value as [x]{.literal}. Then, we define a [for]{.literal} loop
that will iterate over the integers from 2 to [n]{.literal} at
[➋]{.ent}. Each time the loop iterates, it adds each term to
[series]{.literal} at [➌]{.ent}, as follows:

i = 2, series = x + x\*\*2 / 2\
i = 3, series = x + x\*\*2/2 + x\*\*3/3\
\
\--[snip]{.codeitalic}\--

[]{#page_100}The value of [series]{.literal} starts off as just plain
[x]{.literal}, but with each iteration, [x\*\*i/i]{.literal} gets added
to the value of [series]{.literal} until the series we want is
completed. You can see SymPy addition put to good use here. Finally, the
[pprint()]{.literal} function is used to print the series.

When you run the program, it asks you to input a number and then prints
the series up to that term:

Enter the number of terms you want in the series: [5]{.codestrong}\
\
    x^2^ x^3^ x^4^ x^5^\
x + \-- + \-- + \-- + \--\
    2    3    4    5

Try this out with a different number of terms every time. Next, we'll
see how to calculate the sum of this series for a certain value of *x*.

#### ***Substituting in Values*** {#ch04lev2sec03 .h4}

Let's see how we can use SymPy to plug values into an algebraic
expression. This will let us calculate the value of the expression for
certain values of the variables. Consider the mathematical expression
*x*^2^ + 2*xy* + *y*^2^, which can be defined as follows:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [y = Symbol(\'y\')]{.codestrong}\
\>\>\> [x\*x + x\*y + x\*y + y\*y]{.codestrong}\
x\*\*2 + 2\*x\*y + y\*\*2

If you want to evaluate this expression, you can substitute numbers in
for the symbols using the [subs()]{.literal} method:

[➊]{.ent} \>\>\> [expr = x\*x + x\*y + x\*y + y\*y]{.codestrong}\
   \>\>\> [res = expr.subs({x:1, y:2})]{.codestrong}

First, we create a new label to refer to the expression at [➊]{.ent},
and then we call the [subs()]{.literal} method. The argument to the
[subs()]{.literal} method is a Python *dictionary*, which contains the
two symbol labels and the numerical values we want to substitute in for
each symbol. Let's check out the result:

\>\>\> [res]{.codestrong}\
9

You can also express one symbol in terms of another and substitute
accordingly, using the [subs()]{.literal} method. For example, if you
knew that *x* = 1 -- *y*, here's how you could evaluate the preceding
expression:

\>\>\> [expr.subs({x:1-y})]{.codestrong}\
y\*\*2 + 2\*y\*(-y + 1) + (-y + 1)\*\*2

::: {.sidebar}
[]{#page_101}**PYTHON DICTIONARIES**

A dictionary is another type of data structure in Python (lists and
tuples are other examples of data structures, which you've seen
earlier). Dictionaries contain key-value pairs inside curly braces,
where each key is matched up with a value, separated by a colon. In the
preceding code listing, we entered the dictionary [{x:1, y:2}]{.literal}
as an argument to the [subs()]{.literal} method. This dictionary has two
key-value pairs---[x:1]{.literal} and [y:2]{.literal}, where
[x]{.literal} and [y]{.literal} are the keys and [1]{.literal} and
[2]{.literal} are the corresponding values. You can retrieve a value
from a dictionary by entering its associated key in brackets, much as we
would retrieve an element from a list using its index. For example, here
we create a simple dictionary and then retrieve the value corresponding
to [key1]{.literal}:

\>\>\> [sampledict = {\"key1\": 5, \"key2\": 20}]{.codestrong}\
\>\>\> [sampledict\[\"key1\"\]]{.codestrong}\
5

To learn more about dictionaries, see [Appendix B](app02.html#app02).
:::

If you want the result to be simplified further---for example, if there
are terms that cancel each other out, we can use SymPy's
[simplify()]{.literal} function, as follows:

[➊]{.ent} \>\>\> [expr\_subs = expr.subs({x:1-y})]{.codestrong}\
   \>\>\> [from sympy import simplify]{.codestrong}\
[➋]{.ent} \>\>\> [simplify(expr\_subs)]{.codestrong}\
   1

At [➊]{.ent}, we create a new label, [expr\_subs]{.literal}, to refer to
the result of substituting *x* = 1 -- *y* in the expression. We then
import the [simplify()]{.literal} function from SymPy and call it at
[➋]{.ent}. The result turns out to be 1 because the other terms of the
expression cancel each other.

Although there was a simplified version of the expression in the
preceding example, you had to ask SymPy to simplify it using the
[simplify()]{.literal} function. Once again, this is because SymPy won't
do any simplification without being asked to.

The [simplify()]{.literal} function can also simplify complicated
expressions, such as those including logarithms and trigonometric
functions, but we won't get into that here.

##### []{#page_102}**Calculating the Value of a Series** {#ch04lev3sec02 .h5}

Let's revisit the series-printing program. In addition to printing the
series, we want our program to be able to find the value of the series
for a particular value of *x*. That is, our program will now take two
inputs from the user---the number of terms in the series and the value
of *x* for which the value of the series will be calculated. Then, the
program will output both the series and the sum. The following program
extends the series printing program to include these enhancements:

   \'\'\'\
   Print the series:\
   x + x\*\*2 + x\*\*3 + \... + x\*\*n\
       \_\_\_\_  \_\_\_\_\_         \_\_\_\_\_\
         2     3             n\
   \'\'\'\
\
   from sympy import Symbol, pprint, init\_printing\
   def print\_series(n, x\_value):\
\
       \# Initialize printing system with reverse order\
       init\_printing(order=\'rev-lex\')\
\
       x = Symbol(\'x\')\
       series = x\
       for i in range(2, n+1):\
           series = series + (x\*\*i)/i\
\
       pprint(series)\
\
       \# Evaluate the series at x\_value\
[➊]{.ent}     series\_value = series.subs({x:x\_value})\
       print(\'Value of the series at {0}: {1}\'.format(x\_value, series\_value))\
\
   if \_\_name\_\_ == \'\_\_main\_\_\':\
       n = input(\'Enter the number of terms you want in the series: \')\
[➋]{.ent}     x\_value = input(\'Enter the value of x at which you want to evaluate the series: \')\
\
       print\_series(int(n), float(x\_value))

The [print\_series()]{.literal} function now takes an additional
argument, [x\_value]{.literal}, which is the value of [x]{.literal} for
which the series should be evaluated. At [➊]{.ent}, we use the
[subs()]{.literal} method to perform the evaluation and the label
[series\_value]{.literal} to refer to the result. In the next line, we
display the result.

The additional input statement at [➋]{.ent} asks the user to enter the
value of [x]{.literal} using the label [x\_value]{.literal} to refer to
it. Before we call the [print\_series()]{.literal} function, we convert
this value into its floating point equivalent using the
[float()]{.literal} function.

[]{#page_103}If you execute the program now, it will ask you for the two
inputs and print out the series and the series value:

Enter the number of terms you want in the series: [5]{.codestrong}\
Enter the value of x at which you want to evaluate the series: [1.2]{.codestrong}\
\
    x^2^ x^3^ x^4^ x^5^\
x + \-- + \-- + \-- + \--\
    2    3    4    5\
Value of the series at 1.2: 3.51206400000000

In this sample run, we ask for five terms in the series, with
[x]{.literal} set to 1.2, and the program prints and evaluates the
series.

#### ***Converting Strings to Mathematical Expressions*** {#ch04lev2sec04 .h4}

So far, we've been writing out individual expressions each time we want
to do something with them. However, what if you wanted to write a more
general program that could manipulate any expression provided by the
user? For that, we need a way to convert a user's input, which is a
string, into something we can perform mathematical operations on.
SymPy's [sympify()]{.literal} function helps us do exactly that. The
function is so called because it converts the string into a SymPy object
that makes it possible to apply SymPy's functions to the input. Let's
see an example:

[➊]{.ent} \>\>\> [from sympy import sympify]{.codestrong}\
   \>\>\> [expr = input(\'Enter a mathematical expression: \')]{.codestrong}\
   Enter a mathematical expression: [x\*\*2 + 3\*x + x\*\*3 + 2\*x]{.codestrong}\
[➋]{.ent} \>\>\> [expr = sympify(expr)]{.codestrong}

We first import the [sympify()]{.literal} function at [➊]{.ent}. We then
use the [input()]{.literal} function to ask for a mathematical
expression as input, using the label [expr]{.literal} to refer to it.
Next, we call the [sympify()]{.literal} function with [expr]{.literal}
as its argument at [➋]{.ent} and use the same label to refer to the
converted expression.

You can perform various operations on this expression. For example,
let's try multiplying the expression by 2:

\>\>\> [2\*expr]{.codestrong}\
2\*x\*\*3 + 2\*x\*\*2 + 10\*x

What happens when the user supplies an invalid expression? Let's see:

\>\>\> [expr = input(\'Enter a mathematical expression: \')]{.codestrong}\
Enter a mathematical expression: [x\*\*2 + 3\*x + x\*\*3 + 2x]{.codestrong}\
\>\>\> [expr = sympify(expr)]{.codestrong}\
Traceback (most recent call last):\
  File \"\<pyshell\#146\>\", line 1, in \<module\>\
    expr = sympify(expr)\
  File \"/usr/lib/python3.3/site-packages/sympy/core/sympify.py\", line 180, in sympify\
    raise SympifyError(\'could not parse %r\' % a)\
sympy.core.sympify.SympifyError: SympifyError: \"could not parse \'x\*\*2 + 3\*x + x\*\*3 + 2x\'\"

[]{#page_104}The last line tells us that [sympify()]{.literal} isn't
able to convert the supplied input expression. Because this user didn't
add an operator between [2]{.literal} and [x]{.literal}, SymPy doesn't
understand what it means. Your program should expect such invalid input
and print an error message if it comes up. Let's see how we can do that
by catching the [SympifyError]{.literal} exception:

\>\>\> [from sympy import sympify]{.codestrong}\
\>\>\> [from sympy.core.sympify import SympifyError]{.codestrong}\
\>\>\> [expr = input(\'Enter a mathematical expression: \')]{.codestrong}\
Enter a mathematical expression: [x\*\*2 + 3\*x + x\*\*3 + 2x]{.codestrong}\
\>\>\> [try:]{.codestrong}\
    [expr = sympify(expr)]{.codestrong}\
[except SympifyError:]{.codestrong}\
    [print(\'Invalid input\')]{.codestrong}\
\
Invalid input

The two changes in the preceding program are that we import the
[SympifyError]{.literal} exception class from the
[sympy.core.sympify]{.literal} module and call the [sympify()]{.literal}
function in a [try\...except]{.literal} block. Now if there's a
[SympifyError]{.literal} exception, an error message is printed.

##### **Expression Multiplier** {#ch04lev3sec03 .h5}

Let's apply the [sympify()]{.literal} function to write a program that
calculates the product of two expressions:

   \'\'\'\
   Product of two expressions\
   \'\'\'\
\
   from sympy import expand, sympify\
   from sympy.core.sympify import SympifyError\
\
   def product(expr1, expr2):\
       prod = expand(expr1\*expr2)\
       print(prod)\
\
   if \_\_name\_\_==\'\_\_main\_\_\':\
[➊]{.ent}     expr1 = input(\'Enter the first expression: \')\
[➋]{.ent}     expr2 = input(\'Enter the second expression: \')\
\
       try:\
           expr1 = sympify(expr1)\
           expr2 = sympify(expr2)\
       except SympifyError:\
           print(\'Invalid input\')\
       else:\
[➌]{.ent}         product(expr1, expr2)

At [➊]{.ent} and [➋]{.ent}, we ask the user to enter the two
expressions. Then, we convert them into a form understood by SymPy using
the [sympify()]{.literal} function []{#page_105}in a
[try\...except]{.literal} block. If the conversion succeeds (indicated
by the [else]{.literal} block), we call the [product()]{.literal}
function at [➌]{.ent}. In this function, we calculate the product of the
two expressions and print it. Note how we use the [expand()]{.literal}
function to print the product so that all its terms are expressed as a
sum of its constituent terms.

Here's a sample execution of the program:

Enter the first expression: [x\*\*2 + x\*2 + x]{.codestrong}\
Enter the second expression: [x\*\*3 + x\*3 + x]{.codestrong}\
x\*\*5 + 3\*x\*\*4 + 4\*x\*\*3 + 12\*x\*\*2

The last line displays the product of the two expressions. The input can
also have more than one symbol in any of the expressions:

Enter the first expression: [x\*y+x]{.codestrong}\
Enter the second expression: [x\*x+y]{.codestrong}\
x\*\*3\*y + x\*\*3 + x\*y\*\*2 + x\*y

### **Solving Equations** {#ch04lev1sec03 .h3}

SymPy's [solve()]{.literal} function can be used to find solutions to
equations. When you input an expression with a symbol representing a
variable, such as *x*, [solve()]{.literal} calculates the value of that
symbol. This function always makes its calculation by assuming the
expression you enter is equal to zero---that is, it prints the value
that, when substituted for the symbol, makes the entire expression equal
zero. Let's start with the simple equation *x* -- 5 = 7. If we want to
use [solve()]{.literal} to find the value of [x]{.literal}, we first
have to make one side of the equation equal zero (*x* -- 5 -- 7 = 0).
Then, we're ready to use [solve()]{.literal}, as follows:

\>\>\> [from sympy import Symbol, solve]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [expr = x - 5 - 7]{.codestrong}\
\>\>\> [solve(expr)]{.codestrong}\
\[12\]

When we use [solve()]{.literal}, it calculates the value of
[\'x\']{.literal} as 12 because that's the value that makes the
expression (*x* -- 5 -- 7) equal to zero.

Note that the result 12 is returned in a list. An equation can have
multiple solutions---for example, a quadratic equation has two
solutions. In that case, the list will have all the solutions as its
members. You can also ask the [solve()]{.literal} function to return the
result so that each member is dictionary instead. Each dictionary is
composed of the symbol (variable name) and its value (the solution).
This is especially useful when solving simultaneous equations where we
have more than one variable to solve for because when the solution is
returned as a dictionary, we know which solution corresponds to which
variable.

#### []{#page_106}***Solving Quadratic Equations*** {#ch04lev2sec05 .h4}

In [Chapter 1](ch01.html#ch01), we found the roots of the quadratic
equation *ax*^2^ + *bx* + *c* = 0 by writing the formulas for the two
roots and then substituting the values of the constants *a*, *b*, and
*c*. Now, we'll learn how we can use SymPy's [solve()]{.literal}
function to find the roots without needing to write out the formulas.
Let's see an example:

[➊]{.ent} \>\>\> [from sympy import solve]{.codestrong}\
   \>\>\> [x = Symbol(\'x\')]{.codestrong}\
[➋]{.ent} \>\>\> [expr = x\*\*2 + 5\*x + 4]{.codestrong}\
[➌]{.ent} \>\>\> [solve(expr, dict=True)]{.codestrong}\
[➍]{.ent} \[{x: -4}, {x: -1}\]

The [solve()]{.literal} function is first imported at [➊]{.ent}. We then
define a symbol, [x]{.literal}, and an expression corresponding to the
quadratic equation, [x\*\*2 + 5\*x + 4]{.literal}, at [➋]{.ent}. Then,
we call the [solve()]{.literal} function with the preceding expression
at [➌]{.ent}. The second argument to the [solve()]{.literal} function
([dict=True]{.literal}) specifies that we want the result to be returned
as a list of Python dictionaries.

Each solution in the returned list is a dictionary using the symbol as a
key matched with its corresponding value. If the solution is empty, an
empty list will be returned. The roots of the preceding equation are --4
and --1, as you can see at [➍]{.ent}.

We found out in the first chapter that the roots of the equation

*x*^2^ + *x* + 1 = 0

are complex numbers. Let's attempt to find those using
[solve()]{.literal}:

\>\>\> [x=Symbol(\'x\')]{.codestrong}\
\>\>\> [expr = x\*\*2 + x + 1]{.codestrong}\
\>\>\> [solve(expr, dict=True)]{.codestrong}\
\[{x: -1/2 - sqrt(3)\*I/2}, {x: -1/2 + sqrt(3)\*I/2}\]

Both the roots are imaginary, as expected with the imaginary component
indicated by the [I]{.literal} symbol.

#### ***Solving for One Variable in Terms of Others*** {#ch04lev2sec06 .h4}

In addition to finding the roots of equations, we can take advantage of
symbolic math to use the [solve()]{.literal} function to express one
variable in an equation in terms of the others. Let's take a look at
finding the roots for the generic quadratic equation *ax*^2^ + *bx* +
*c* = 0. To do so, we'll define *x* and three additional symbols---*a*,
*b*, and *c*, which correspond to the three constants:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [a = Symbol(\'a\')]{.codestrong}\
\>\>\> [b = Symbol(\'b\')]{.codestrong}\
\>\>\> [c = Symbol(\'c\')]{.codestrong}

[]{#page_107}Next, we write the expression corresponding to the equation
and use the [solve()]{.literal} function on it:

\>\>\> [expr = a\*x\*x + b\*x + c]{.codestrong}\
\>\>\> [solve(expr, x, dict=True)]{.codestrong}\
\[{x: (-b + sqrt(-4\*a\*c + b\*\*2))/(2\*a)}, {x: -(b + sqrt(-4\*a\*c + b\*\*2))/(2\*a)}\]

Here, we have to include an additional argument, [x]{.literal}, to the
[solve()]{.literal} function. Because there's more than one symbol in
the equation, we need to tell [solve()]{.literal} which symbol it should
solve for, which is what we indicate by passing in [x]{.literal} as the
second argument. As we'd expect, [solve()]{.literal} prints the
quadratic formula: the generic formula for finding the value(s) of *x*
in a polynomial expression.

To be clear, when we use [solve()]{.literal} on an equation with more
than one symbol, we specify the symbol to solve for as the second
argument (and now the third argument specifies how we want the results
to be returned).

Next, let's consider an example from physics. According to one of the
equations of motion, the distance traveled by a body moving with a
constant acceleration *a*, with an initial velocity *u*, in time *t*, is
given by

::: {.image2}
![image](graphics/e0107-01.jpg)
:::

Given *u* and *a*, however, if you wanted to find the time required to
travel a given distance, *s*, you'd have to first express *t* in terms
of the other variables. Here's how you could do that using SymPy's
[solve()]{.literal} function:

\>\>\> [from sympy import Symbol, solve, pprint]{.codestrong}\
\>\>\> [s = Symbol(\'s\')]{.codestrong}\
\>\>\> [u = Symbol(\'u\')]{.codestrong}\
\>\>\> [t = Symbol(\'t\')]{.codestrong}\
\>\>\> [a = Symbol(\'a\')]{.codestrong}\
\>\>\> [expr = u\*t + (1/2)\*a\*t\*t - s]{.codestrong}\
\>\>\> [t\_expr = solve(expr,t, dict=True)]{.codestrong}\
\>\>\> [pprint(t\_expr)]{.codestrong}

The result looks like this:

::: {.image2}
![image](graphics/f0107-01.jpg)
:::

Now that we have the expression for *t* (referred to by the label
[t\_expr]{.literal}), we can use the [subs()]{.literal} method to
replace the values of *s*, *u*, and *a* to find the two possible values
of *t*.

#### []{#page_108}***Solving a System of Linear Equations*** {#ch04lev2sec07 .h4}

Consider the following two equations:

2*x* + 3*y* = 6

3*x* + 2*y* = 12

Say we want to find the pair of values (*x*, *y*) that satisfies both
the equations. We can use the [solve()]{.literal} function to find the
solution for a system of equations like this one.

First, we define the two symbols and create the two equations:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [y = Symbol(\'y\')]{.codestrong}\
\>\>\> [expr1 = 2\*x + 3\*y - 6]{.codestrong}\
\>\>\> [expr2 = 3\*x + 2\*y -- 12]{.codestrong}

The two equations are defined by the expressions [expr1]{.literal} and
[expr2]{.literal}, respectively. Note how we've rearranged the
expressions so they both equal zero (we moved the right side of the
given equations to the left side). To find the solution, we call the
[solve()]{.literal} function with the two expressions forming a tuple:

\>\>\> [solve((expr1, expr2), dict=True)]{.codestrong}\
\[{y: -6/5, x: 24/5}\]

As I mentioned earlier, getting the solution back as a dictionary is
useful here. We can see that the value of [x]{.literal} is 24/5 and the
value of [y]{.literal} is --6/5. Let's verify whether the solution we
got really satisfies the equations. To do so, we'll first create a
label, [soln]{.literal}, to refer to the solution we got and then use
the [subs()]{.literal} method to substitute the corresponding values of
[x]{.literal} and [y]{.literal} in the two expressions:

\>\>\> [soln = solve((expr1, expr2), dict=True)]{.codestrong}\
\>\>\> [soln = soln\[0\]]{.codestrong}\
\>\>\> [expr1.subs({x:soln\[x\], y:soln\[y\]})]{.codestrong}\
0\
\>\>\> [expr2.subs({x:soln\[x\], y:soln\[y\]})]{.codestrong}\
0

The result of substituting the values of [x]{.literal} and [y]{.literal}
corresponding to the solution in the two expressions is zero.

### **Plotting Using SymPy** {#ch04lev1sec04 .h3}

In [Chapter 2](ch02.html#ch02), we learned to make graphs where we
explicitly specified the numbers we wanted to plot. For example, to plot
the graph of the gravitational force against the distance between two
bodies, you had to calculate []{#page_109}the gravitational force for
each distance value and supply the lists of distances and forces to
matplotlib. With SymPy, on the other hand, you can just tell SymPy the
equation of the line you want to plot, and the graph will be created for
you. Let's plot a line whose equation is given by *y* = 2*x* + 3:

\>\>\> [from sympy.plotting import plot]{.codestrong}\
\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [plot(2\*x+3)]{.codestrong}

All we had to do was import [plot]{.literal} and [Symbol]{.literal} from
[sympy.plotting]{.literal}, create a symbol, [x]{.literal}, and call the
[plot()]{.literal} function with the expression [2\*x+3]{.literal}.
SymPy takes care of everything else and plots the graph of the function,
as shown in [Figure 4-1](ch04.html#ch4fig1).

::: {.image}
![image](graphics/f04-01.jpg)
:::

[]{#ch4fig1}*Figure 4-1: Plot of the line* y = *2*x + *3*

The graph shows that a default range of *x* values was automatically
chosen: --10 to 10. You may notice that the graph window looks very
similar to those you saw in [Chapters 2](ch02.html#ch02) and
[3](ch03.html#ch03). That's because SymPy uses matplotlib behind the
scenes to draw the graphs. Also note that we didn't have to call the
[show()]{.literal} function to show the graphs because this is done
automatically by SymPy.

[]{#page_110}Now, let's say that you wanted to limit the values of
[\'x\']{.literal} in the preceding graph to lie in the range --5 to 5
(instead of --10 to 10). You'd do that as follows:

\>\>\> [plot((2\*x + 3), (x, -5, 5))]{.codestrong}

Here, a tuple consisting of the symbol, the lower bound, and the upper
bound of the range---[(x, -5, 5)]{.literal}---is specified as the second
argument to the [plot()]{.literal} function. Now, the graph displays
only the values of *y* corresponding to the values of *x* between --5
and 5 (see [Figure 4-2](ch04.html#ch4fig2)).

::: {.image}
![image](graphics/f04-02.jpg)
:::

[]{#ch4fig2}*Figure 4-2: Plot of the line* y = *2*x + *3 with the values
of* x *restricted to the range --5 to 5*

You can use other keyword arguments in the [plot()]{.literal} function,
such as [title]{.literal} to enter a title or [xlabel]{.literal} and
[ylabel]{.literal} to label the *x*-axis and the *y*-axis, respectively.
The following [plot()]{.literal} function specifies the preceding three
keyword arguments (see the corresponding graph in [Figure
4-3](ch04.html#ch4fig3)):

\>\>\> [plot(2\*x + 3, (x, -5, 5), title=\'A Line\', xlabel=\'x\', ylabel=\'2x+3\')]{.codestrong}

::: {.image}
[]{#page_111}![image](graphics/f04-03.jpg)
:::

[]{#ch4fig3}*Figure 4-3: Plot of the line* y = *2*x + *3 with the range
of* x *and other attributes specified*

The plot shown in [Figure 4-3](ch04.html#ch4fig3) now has a title and
labels on the *x*-axis and the *y*-axis. You can specify a number of
other keyword arguments to the [plot()]{.literal} function to customize
the behavior of the function as well as the graph itself. The
[show]{.literal} keyword argument allows us to specify whether we want
the graph to be displayed. Passing [show=False]{.literal} will cause the
graph to not be displayed when you call the [plot()]{.literal} function:

\>\>\> [p = plot(2\*x + 3, (x, -5, 5), title=\'A Line\', xlabel=\'x\', ylabel=\'2x+3\', show=False)]{.codestrong}

You will see that no graph is shown. The label [p]{.literal} refers to
the plot that is created, so you can now call [p.show()]{.literal} to
display the graph. You can also save the graph as an image file using
the [save()]{.literal} method, as follows:

\>\>\> [p.save(\'line.png\')]{.codestrong}

This will save the plot to a file *line.png* in the current directory.

#### ***Plotting Expressions Input by the User*** {#ch04lev2sec08 .h4}

The expression that you pass to the [plot()]{.literal} function must be
expressed in terms of *x* only. For example, earlier we plotted *y* =
2*x* + 3, which we entered to the plot function as simply 2*x* + 3. If
the expression were not originally in this form, we'd have to rewrite
it. Of course, we could do this manually, []{#page_112}outside the
program. But what if you want to write a program that allows its users
to graph any expression? If the user enters an expression in the form of
2*x* + 3*y* -- 6, say, we have to first convert it. The
[solve()]{.literal} function will help us here. Let's see an example:

   \>\>\> [expr = input(\'Enter an expression: \')]{.codestrong}\
   Enter an expression: [2\*x + 3\*y - 6]{.codestrong}\
[➊]{.ent} \>\>\> [expr = sympify(expr)]{.codestrong}\
[➋]{.ent} \>\>\> [y = Symbol(\'y\')]{.codestrong}\
   \>\>\> [solve(expr, y)]{.codestrong}\
[➌]{.ent} \[-2\*x/3 + 2\]

At [➊]{.ent}, we use the [sympify()]{.literal} function to convert the
input expression to a SymPy object. At [➋]{.ent}, we create a
[Symbol]{.literal} object to represent [\'y\']{.literal} so that we can
tell SymPy which variable we want to solve the equation for. Then we
solve the expression to find [y]{.literal} in terms of [x]{.literal} by
specifying [y]{.literal} as the second argument to the
[solve()]{.literal} function. At [➌]{.ent}, this returns the equation in
terms of [x]{.literal}, which is what we need for plotting.

Notice that this final expression is stored in a list, so before we can
use it, we'll have to extract it from the list:

   \>\>\> [solutions = solve(expr, \'y\')]{.codestrong}\
[➍]{.ent} \>\>\> [expr\_y = solutions\[0\]]{.codestrong}\
   \>\>\> [expr\_y]{.codestrong}\
   -2\*x/3 + 2

We create a label, [solutions]{.literal}, to refer to the result
returned by the [solve()]{.literal} function, which is a list with only
one item. Then, we extract that item at [➍]{.ent}. Now, we can call the
[plot()]{.literal} function to graph the expression. The next listing
shows a full graph-drawing program:

\'\'\'\
Plot the graph of an input expression\
\'\'\'\
\
from sympy import Symbol, sympify, solve, SympifyError\
from sympy.plotting import plot\
\
def plot\_expression(expr):\
\
    y = Symbol(\'y\')\
    solutions = solve(expr, y)\
    expr\_y = solutions\[0\]\
    plot(expr\_y)\
\
if \_\_name\_\_==\'\_\_main\_\_\':\
\
    expr = input(\'Enter your expression in terms of x and y: \')\
[]{#page_113}\
    try:\
        expr = sympify(expr)\
    except SympifyError:\
        print(\'Invalid input\')\
    else:\
        plot\_expression(expr)

Note that the preceding program includes a [try\...except]{.literal}
block to check for invalid input, as we've done with
[sympify()]{.literal} earlier. When you run the program, it asks you to
input an expression, and it will create the corresponding graph.

#### ***Plotting Multiple Functions*** {#ch04lev2sec09 .h4}

You can enter multiple expressions when calling the SymPy
[plot]{.literal} function to plot more than one expression on the same
graph. For example, the following code plots two lines at once (see
[Figure 4-4](ch04.html#ch4fig4)):

\>\>\> [from sympy.plotting import plot]{.codestrong}\
\>\>\> [from sympy import Symbol]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [plot(2\*x+3, 3\*x+1)]{.codestrong}

::: {.image}
![image](graphics/f04-04.jpg)
:::

[]{#ch4fig4}*Figure 4-4: Plotting two lines on the same graph*

[]{#page_114}This example brings out another difference between plotting
in matplotlib and in SymPy. Here, using SymPy, both lines are the same
color, whereas matplotlib would have automatically made the lines
different colors. To set different colors for each line with SymPy,
we'll need to perform some extra steps, as shown in the following code,
which also adds a legend to the graph:

   \>\>\> [from sympy.plotting import plot]{.codestrong}\
   \>\>\> [from sympy import Symbol]{.codestrong}\
   \>\>\> [x = Symbol(\'x\')]{.codestrong}\
[➊]{.ent} \>\>\> [p = plot(2\*x+3, 3\*x+1, legend=True, show=False)]{.codestrong}\
[➋]{.ent} \>\>\> [p\[0\].line\_color = \'b\']{.codestrong}\
[➌]{.ent} \>\>\> [p\[1\].line\_color = \'r\']{.codestrong}\
   \>\>\> [p.show()]{.codestrong}

At [➊]{.ent}, we call the [plot()]{.literal} function with the equations
for the two lines but pass two additional keyword
arguments---[legend]{.literal} and [show]{.literal}. By setting the
legend argument to [True]{.literal}, we add a legend to the graph, as we
saw in [Chapter 2](ch02.html#ch02). Note, however, that the text that
appears in the legend will match the expressions you plotted---you can't
specify any other text. We also set [show=False]{.literal} because we
want to set the color of the lines before we draw the graph. The
statement at [➋]{.ent}, [p\[0\]]{.literal}, refers to the first line,
2*x* + 3, and we set its attribute [line\_color]{.literal} to
[\'b\']{.literal}, meaning that we want this line to be blue. Similarly,
we set the color of the second plot to red using the string
[\'r\']{.literal} [➌]{.ent}. Finally, we call the [show()]{.literal} to
display the graph (see [Figure 4-5](ch04.html#ch4fig5)).

::: {.image}
![image](graphics/f04-05.jpg)
:::

[]{#ch4fig5}*Figure 4-5: Plot of the two lines with each line drawn in a
different color*

[]{#page_115}In addition to red and blue, you can plot the lines in
green, cyan, magenta, yellow, black, and white (using the first letter
of the color in each case, except black for which you use
[\'k\']{.literal}).

### **What You Learned** {#ch04lev1sec05 .h3}

In this chapter, you learned the basics of symbolic math using SymPy.
You learned about declaring symbols, constructing expressions using
symbols and mathematical operators, solving equations, and plotting
graphs. You will be learning more features of SymPy in later chapters.

### **[Programming Challenges]{.bordera}** {#ch04lev1sec06 .h3}

Here are a few programming challenges that should help you further apply
what you've learned. You can find sample solutions at
*<http://www.nostarch.com/doingmathwithpython/>*.

#### ***\#1: Factor Finder*** {#ch04lev2sec10 .h4}

You learned about the [factor()]{.literal} function, which prints the
factors of an expression. Now that you know how your program can handle
expressions input by a user, write a program that will ask the user to
input an expression, calculate its factors, and print them. Your program
should be able to handle invalid input by making use of exception
handling.

#### ***\#2: Graphical Equation Solver*** {#ch04lev2sec11 .h4}

Earlier, you learned how to write a program that prompts the user to
input an expression such as 3*x* + 2*y* -- 6 and create the
corresponding graph. Write a program that asks the user for two
expressions and then graphs them both, as follows:

\>\>\> [expr1 = input(\'Enter your first expression in terms of x and y: \')]{.codestrong}\
\>\>\> [expr2 = input(\'Enter your second expression in terms of x and y: \')]{.codestrong}

Now, [expr1]{.literal} and [expr2]{.literal} will store the two
expressions input by the user. You should convert both of these into
SymPy objects using the [sympify()]{.literal} step in a
[try\...except]{.literal} block.

All you need to do from here is plot these two expressions instead of
one.

Once you've completed this, enhance your program to print the
solution---the pair of *x* and *y* values that satisfies both equations.
This will also be the spot where the two lines on the graph intersect.
(Hint: Refer to how we used the [solve()]{.literal} function earlier to
find the solution of a system of two linear equations.)

#### []{#page_116}***\#3: Summing a Series*** {#ch04lev2sec12 .h4}

We saw how to find the sum of a series in "[Printing a
Series](ch04.html#ch04lev3sec01)" on [page 99](ch04.html#page_99).
There, we manually added the terms of the series by looping over all the
terms. Here's a snippet from that program:

for i in range(2, n+1):\
    series = series + (x\*\*i)/i

SymPy's [summation()]{.literal} function can be directly used to find
such summations. The following example prints the sum of the first five
terms of the series we considered earlier:

   \>\>\> [from sympy import Symbol, summation, pprint]{.codestrong}\
   \>\>\> [x = Symbol(\'x\')]{.codestrong}\
   \>\>\> [n = Symbol(\'n\')]{.codestrong}\
[➊]{.ent} \>\>\> [s = summation(x\*\*n/n, (n, 1, 5))]{.codestrong}\
   \>\>\> [pprint(s)]{.codestrong}\
   x^5^   x^4^   x^3^   x^2^\
   \-- + \-- + \-- + \-- + x\
   5     4   3     2

We call the [summation()]{.literal} function at [➊]{.ent}, with the
first argument being the *n*th term of the series and the second
argument being a tuple that states the range of *n*. We want the sum of
the first five terms here, so the second argument is [(n, 1,
5)]{.literal}.

Once you have the sum, you can use the [subs()]{.literal} method to
substitute a value for *x* to find the numerical value of the sum:

\>\>\> [s.subs({x:1.2})]{.codestrong}\
3.51206400000000

Your challenge is to write a program that's capable of finding the sum
of an arbitrary series when you supply the *n*th term of the series and
the number of terms in it. Here's an example of how the program would
work:

Enter the nth term: [a+(n-1)\*d]{.codestrong}\
Enter the number of terms: [3]{.codestrong}\
3·a + 3·d

In this example, the *n*th term supplied is that of an *arithmetic
progression*. Starting with [a]{.literal} and [d]{.literal} as the
*common difference*, the number of terms up to which the sum is to be
calculated is 3. The sum turns out to be [3a + 3d]{.literal}, which
agrees with the known formula for the same.

#### []{#page_117}***\#4: Solving Single-Variable Inequalities*** {#ch04lev2sec13 .h4}

You've seen how to solve an equation using SymPy's [solve()]{.literal}
function. But SymPy is also capable of solving single-variable
inequalities, such as *x* + 5 \> 3 and sin*x* -- 0.6 \> 0. That is,
SymPy can solve relations besides equality, like \>, \<, and so on. For
this challenge, create a function, [isolve()]{.literal}, that will take
any inequality, solve it, and then return the solution.

First, let's learn about the SymPy functions that will help you
implement this. The inequality-solving functions are available as three
separate functions for polynomial, rational, and all other inequalities.
We'll need to pick the right function to solve various inequalities, or
we'll get an error.

A *polynomial* is an algebraic expression consisting of a variable and
coefficients and involving only the operations of addition, subtraction,
and multiplication and only positive powers of the variable. An example
of a polynomial inequality is *x*^2^ + 4 \< 0.

To solve a polynomial inequality, use the
[solve\_poly\_inequality()]{.literal} function:

   \>\>\> [from sympy import Poly, Symbol, solve\_poly\_inequality]{.codestrong}\
   \>\>\> [x = Symbol(\'x\')]{.codestrong}\
[➊]{.ent} \>\>\> [ineq\_obj = -x\*\*2 + 4 \< 0]{.codestrong}\
[➋]{.ent} \>\>\> [lhs = ineq\_obj.lhs]{.codestrong}\
[➌]{.ent} \>\>\> [p = Poly(lhs, x)]{.codestrong}\
[➍]{.ent} \>\>\> [rel = ineq\_obj.rel\_op]{.codestrong}\
   \>\>\> [solve\_poly\_inequality(p, rel)]{.codestrong}\
   \[(-oo, -2), (2, oo)\]

First, create the expression representing an inequality, --*x*^2^ + 4 \<
0, at [➊]{.ent} and refer to this expression with the label
[ineq\_obj]{.literal}. Then, extract the left side of the
inequality---that is, the algebraic expression --*x*^2^ + 4---using the
[lhs]{.literal} attribute at [➋]{.ent}. Next, create a [Poly]{.literal}
object at [➌]{.ent} to represent the polynomial we extracted at
[➋]{.ent}. The second argument passed when creating the object is the
symbol object that represents the variable, [x]{.literal}. At [➍]{.ent},
extract the relational operator from the inequality object using the
[rel]{.literal} attribute. Finally, call the
[solve\_poly\_inequality()]{.literal} function with the polynomial
object, [p]{.literal}, and [rel]{.literal} as the two arguments. The
program returns the solution as a list of tuples, with each tuple
representing a solution for the inequality as the lower limit and the
upper limit of the range of numbers. For this inequality, the solution
is all numbers less than --2 and all numbers greater than 2.

A *rational expression* is an algebraic expression in which the
numerator and denominator are both polynomials. Here's an example of a
rational inequality:

::: {.image2}
![image](graphics/e0117-01.jpg)
:::

[]{#page_118}For rational inequalities, use the
[solve\_rational\_inequalities()]{.literal} function:

   \>\>\> [from sympy import Symbol, Poly, solve\_rational\_inequalities]{.codestrong}\
   \>\>\> [x = Symbol(\'x\')]{.codestrong}\
[➊]{.ent} \>\>\> [ineq\_obj = ((x-1)/(x+2)) \> 0]{.codestrong}\
   \>\>\> [lhs = ineq\_obj.lhs]{.codestrong}\
[➋]{.ent} \>\>\> [numer, denom = lhs.as\_numer\_denom()]{.codestrong}\
   \>\>\> [p1 = Poly(numer)]{.codestrong}\
   \>\>\> [p2 = Poly(denom)]{.codestrong}\
   \>\>\> [rel = ineq\_obj.rel\_op]{.codestrong}\
[➌]{.ent} \>\>\> [solve\_rational\_inequalities(\[\[((p1, p2), rel)\]\])]{.codestrong}\
   (-oo, -2) U (1, oo)

Create an inequality object representing our example rational inequality
at [➊]{.ent} and then extract the rational expression using the
[lhs]{.literal} attribute. Separate out the numerator and the
denominator into the labels [numer]{.literal} and [denom]{.literal}
using the [as\_numer\_denom()]{.literal} method at [➋]{.ent}, which
returns a tuple with the numerator and denominator as the two members.
Then, create two polynomial objects, [p1]{.literal} and [p2]{.literal},
representing the numerator and denominator, respectively. Retrieve the
relational operator and call the
[solve\_rational\_inequalities()]{.literal} function, passing it the two
polynomial objects---[p1]{.literal} and [p2]{.literal}---and the
relational operator.

The program returns the solution [(-oo, -2) U (1, oo)]{.literal}, where
[U]{.literal} denotes that the solution is a *union* of the two *sets*
of solutions consisting of all numbers less than --2 and all numbers
greater than 1. (We'll learn about sets in [Chapter 5](ch05.html#ch05).)

Finally, sin*x* -- 0.6 \> 0 is an example of an inequality that belongs
to neither the polynomial nor rational expression categories. If you
have such an inequality to solve, use the
[solve\_univariate\_inequality()]{.literal} function:

\>\>\> [from sympy import Symbol, solve, solve\_univariate\_inequality, sin]{.codestrong}\
\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [ineq\_obj = sin(x) - 0.6 \> 0]{.codestrong}\
\>\>\> [solve\_univariate\_inequality(ineq\_obj, x, relational=False)]{.codestrong}\
(0.643501108793284, 2.49809154479651)

Create an inequality object representing the inequality [sin(x) -- 0.6
\> 0]{.literal} and then call the
[solve\_univariate\_inequality()]{.literal} function with the first two
arguments as the inequality object, [ineq\_obj]{.literal}, and the
symbol object, [x]{.literal}. The keyword argument
[relational=False]{.literal} specifies to the function that we want the
solution to be returned as a *set*. The solution for this inequality
turns out to be all numbers lying between the first and second members
of the tuple the program returns.

##### []{#page_119}**Hints: Handy Functions** {#ch04lev3sec04 .h5}

Now remember---your challenge is (1) to create a function,
[isolve()]{.literal}, that will take any inequality and (2) to choose
one of the appropriate functions discussed in this section to solve it
and return the solution. The following hints may be useful to implement
this function.

The [is\_polynomial()]{.literal} method can be used to check whether an
expression is a polynomial or not:

\>\>\> [x = Symbol(\'x\')]{.codestrong}\
\>\>\> [expr = x\*\*2 - 4]{.codestrong}\
\>\>\> [expr.is\_polynomial()]{.codestrong}\
True\
\>\>\> [expr = 2\*sin(x) + 3]{.codestrong}\
\>\>\> [expr.is\_polynomial()]{.codestrong}\
False

The [is\_rational\_function()]{.literal} can be used to check whether an
expression is a rational expression:

\>\>\> [expr = (2+x)/(3+x)]{.codestrong}\
\>\>\> [expr.is\_rational\_function()]{.codestrong}\
True\
\>\>\> [expr = 2+x]{.codestrong}\
\>\>\> [expr.is\_rational\_function()]{.codestrong}\
True\
\>\>\> [expr = 2+sin(x)]{.codestrong}\
\>\>\> [expr.is\_rational\_function()]{.codestrong}\
False

The [sympify()]{.literal} function can convert an inequality expressed
as a string to an inequality object:

\>\>\> [from sympy import sympify]{.codestrong}\
\>\>\> [sympify(\'x+3\>0\')]{.codestrong}\
x + 3 \> 0

When you run your program, it should ask the user to input an inequality
expression and print back the solution.[]{#page_120}
